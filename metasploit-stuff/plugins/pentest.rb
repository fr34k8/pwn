module Msf
  class Plugin::Pentest < Msf::Plugin

    # Post Exploitation command class
    ################################################################################################
    class PostautoCommandDispatcher

      include Msf::Auxiliary::Report
      include Msf::Ui::Console::CommandDispatcher

      def name
        "Postauto"
      end

      def commands
        {
            'multi_post'        => "Run a post module against specified sessions.",
            'multi_post_rc'     => "Run resource file with post modules and options against specified sessions.",
            'multi_meter_cmd'   => "Run a Meterpreter Console Command against specified sessions.",
            'multi_meter_cmd_rc'=> "Run resource file with Meterpreter Console Commands against specified sessions.",
            "multi_cmd"         => "Run shell command against several sessions",
            "sys_creds"         => "Run system password collection modules against specified sessions.",
            "app_creds"         => "Run application password collection modules against specified sessions."
        }
      end

      # Multi shell command
      def cmd_multi_cmd(*args)
        # Define options
        opts = Rex::Parser::Arguments.new(
            "-s"   => [ true, "Comma separated list sessions to run modules against."],
            "-c"   => [ true, "Shell command to run."],
            "-p"   => [ true, "Platform to run the command against. If none given it will run against all."],
            "-h"   => [ false,  "Command Help."]
        )

        # set variables for options
        sessions = []
        command = ""
        plat = ""

        # Parse options
        opts.parse(args) do |opt, idx, val|
          case opt
            when "-s"
              if val =~ /all/i
                sessions = framework.sessions.keys
              else
                sessions = val.split(",")
              end
            when "-c"
              command = val
            when "-p"
              plat = val
            when "-h"
              print_line(opts.usage)
              return
            else
              print_line(opts.usage)
              return
          end
        end

        # Make sure that proper values where provided
        if not sessions.empty? and not command.empty?
          # Iterate thru the session IDs
          sessions.each do |s|
            # Set the session object
            session = framework.sessions[s.to_i]
            if session.platform =~ /#{plat}/i || plat.empty?
              host = session.tunnel_peer.split(":")[0]
              print_line("Running #{command} against session #{s}")
              # Run the command
              cmd_out = session.shell_command_token(command)
              # Print good each line of the command output
              if not cmd_out.nil?
                cmd_out.each_line do |l|
                  print_line(l.chomp)
                end
                file_name = "#{File.join(Msf::Config.loot_directory,"#{Time.now.strftime("%Y%m%d%H%M%S")}_command.txt")}"
                framework.db.report_loot({ :host=> host,
                                           :path  => file_name,
                                           :ctype => "text/plain",
                                           :ltype => "host.command.shell",
                                           :data  => cmd_out,
                                           :name  => "#{host}.txt",
                                           :info  => "Output of command #{command}" })
              else
                print_error("No output or error when running the command.")
              end
            end
          end
        else
          print_error("You must specify both a session and a command.")
          print_line(opts.usage)
          return
        end
      end

      # Multi_post Command
      #-------------------------------------------------------------------------------------------

      # Function for doing auto complete on module name
      def tab_complete_module(str, words)
        res = []
        framework.modules.module_types.each do |mtyp|
          mset = framework.modules.module_names(mtyp)
          mset.each do |mref|
            res << mtyp + '/' + mref
          end
        end

        return res.sort
      end

      # Function  to do tab complete on modules for multi_post
      def cmd_multi_post_tabs(str, words)
        tab_complete_module(str, words)
      end

      # Function for the multi_post command
      def cmd_multi_post(*args)
        opts = Rex::Parser::Arguments.new(
            "-s"   => [ true,   "Sessions to run module against. Example <all> or <1,2,3,4>"],
            "-m"   => [ true,   "Module to run against sessions."],
            "-o"   => [ true,   "Module options."],
            "-h"   => [ false,  "Command Help."]
        )
        post_mod = ""
        mod_opts = nil
        sessions = ""

        # Parse options
        opts.parse(args) do |opt, idx, val|
          case opt
            when "-s"
              sessions = val
            when "-m"
              post_mod = val.gsub(/^post\//,"")
            when "-o"
              mod_opts = val
            when "-h"
              print_line opts.usage
              return
            else
              print_status "Please specify a module to run with the -m option."
              return
          end
        end
        # Make sure that proper values where provided
        if not sessions.empty? and not post_mod.empty?
          # Set and execute post module with options
          print_line("Loading #{post_mod}")
          m = framework.post.create(post_mod)
          if sessions =~ /all/i
            session_list = m.compatible_sessions
          else
            session_list = sessions.split(",")
          end
          if session_list
            session_list.each do |s|
              if m.session_compatible?(s.to_i)
                print_line("Running against #{s}")
                m.datastore['SESSION'] = s.to_i
                if mod_opts
                  mod_opts.each do |o|
                    opt_pair = o.split("=",2)
                    print_line("\tSetting Option #{opt_pair[0]} to #{opt_pair[1]}")
                    m.datastore[opt_pair[0]] = opt_pair[1]
                  end
                end
                m.options.validate(m.datastore)
                m.run_simple(
                    'LocalInput'  => driver.input,
                    'LocalOutput' => driver.output
                )
              else
                print_error("Session #{s} is not compatible with #{post_mod}.")
              end
            end
          else
            print_error("No compatible sessions were found.")
          end
        else
          print_error("A session or Post Module where not specified.")
          print_line(opts.usage)
          return
        end
      end

      # Multi_post_rc Command
      #-------------------------------------------------------------------------------------------
      def cmd_multi_post_rc_tabs(str, words)
        tab_complete_filenames(str, words)
      end

      def cmd_multi_post_rc(*args)
        opts = Rex::Parser::Arguments.new(
            "-rc"  => [ true,   "Resource file with space separate values <session> <module> <options>, per line."],
            "-h"   => [ false,  "Command Help."]
        )
        post_mod = nil
        session_list = nil
        mod_opts = nil
        entries = []
        opts.parse(args) do |opt, idx, val|
          case opt
            when "-rc"
              script = val
              if not ::File.exists?(script)
                print_error "Resource File does not exists!"
                return
              else
                ::File.open(script, "r").each_line do |line|
                  # Empty line
                  next if line.strip.length < 1
                  # Comment
                  next if line[0,1] == "#"
                  entries << line.chomp
                end
              end
            when "-h"
              print_line opts.usage
              return
            else
              print_line opts.usage
              return
          end
        end
        if entries
          entries.each do |l|
            values = l.split
            sessions = values[0]
            post_mod = values[1]
            if values.length == 3
              mod_opts = values[2].split(",")
            end
            print_line("Loading #{post_mod}")
            m= framework.post.create(post_mod.gsub(/^post\//,""))
            if sessions =~ /all/i
              session_list = m.compatible_sessions
            else
              session_list = sessions.split(",")
            end
            session_list.each do |s|
              if m.session_compatible?(s.to_i)
                print_line("Running Against #{s}")
                m.datastore['SESSION'] = s.to_i
                if mod_opts
                  mod_opts.each do |o|
                    opt_pair = o.split("=",2)
                    print_line("\tSetting Option #{opt_pair[0]} to #{opt_pair[1]}")
                    m.datastore[opt_pair[0]] = opt_pair[1]
                  end
                end
                m.options.validate(m.datastore)
                m.run_simple(
                    'LocalInput'  => driver.input,
                    'LocalOutput' => driver.output
                )
              else
                print_error("Session #{s} is not compatible with #{post_mod}")
              end
            end
          end
        else
          print_error("Resource file was empty!")
        end
      end

      # Multi_meter_cmd Command
      #-------------------------------------------------------------------------------------------
      def cmd_multi_meter_cmd(*args)
        opts = Rex::Parser::Arguments.new(
            "-s"   => [ true,   "Sessions to run Meterpreter Console Command against. Example <all> or <1,2,3,4>"],
            "-c"   => [ true,   "Meterpreter Console Command to run against sessions."],
            "-h"   => [ false,  "Command Help."]
        )
        command = nil
        session = nil

        # Parse options
        opts.parse(args) do |opt, idx, val|
          case opt
            when "-s"
              session = val
            when "-c"
              command = val
            when "-h"
              print_line opts.usage
              return
            else
              print_status "Please specify a command to run with the -m option."
              return
          end
        end
        current_sessions = framework.sessions.keys.sort
        if session =~/all/i
          sessions = current_sessions
        else
          sessions = session.split(",")
        end
        sessions.each do |s|
          # Check if session is in the current session list.
          next if not current_sessions.include?(s.to_i)
          # Get session object
          session = framework.sessions.get(s.to_i)
          # Check if session is meterpreter and run command.
          if (session.type == "meterpreter")
            print_line("Running command #{command} against session #{s}")
            session.console.run_single(command)
          else
            print_line("Session #{s} is not a Meterpreter session!")
          end
        end
      end

      # Multi_post_rc Command
      #-------------------------------------------------------------------------------------------
      def cmd_multi_meter_cmd_rc(*args)
        opts = Rex::Parser::Arguments.new(
            "-rc"  => [ true,   "Resource file with space separate values <session> <command>, per line."],
            "-h"   => [ false,  "Command Help"]
        )
        entries = []
        script = nil
        opts.parse(args) do |opt, idx, val|
          case opt
            when "-rc"
              script = val
              if not ::File.exists?(script)
                print_error "Resource File does not exists"
                return
              else
                ::File.open(script, "r").each_line do |line|
                  # Empty line
                  next if line.strip.length < 1
                  # Comment
                  next if line[0,1] == "#"
                  entries << line.chomp
                end
              end
            when "-h"
              print_line opts.usage
              return
            else
              print_line opts.usage
              return
          end
        end
        entries.each do |entrie|
          session_parm,command = entrie.split(" ", 2)
          current_sessions = framework.sessions.keys.sort
          if session_parm =~ /all/i
            sessions = current_sessions
          else
            sessions = session_parm.split(",")
          end
          sessions.each do |s|
            # Check if session is in the current session list.
            next if not current_sessions.include?(s.to_i)
            # Get session object
            session = framework.sessions.get(s.to_i)
            # Check if session is meterpreter and run command.
            if (session.type == "meterpreter")
              print_line("Running command #{command} against session #{s}")
              session.console.run_single(command)
            else
              print_line("Session #{s} is not a Meterpreter sessions.")
            end
          end
        end
      end
    end


    # Project handling commands
    ################################################################################################
    class ProjectCommandDispatcher
      include Msf::Ui::Console::CommandDispatcher

      # Set name for command dispatcher
      def name
        "Project"
      end

      # Define Commands
      def commands
        {
            "project"     => "Command for managing projects.",
        }
      end

      def cmd_project(*args)
        # variable
        project_name = ""
        create = false
        delete = false
        history = false
        switch = false
        archive = false
        arch_path = ::File.join(Msf::Config.log_directory,"archives")
        # Define options
        opts = Rex::Parser::Arguments.new(
            "-c"   => [ false,  "Create a new Metasploit project and sets logging for it."],
            "-d"   => [ false,  "Delete a project created by the plugin."],
            "-s"   => [ false,  "Switch to a project created by the plugin."],
            "-a"   => [ false,  "Export all history and DB and archive it in to a zip file for current project."],
            "-p"   => [ true,   "Path to save archive, if none provide default ~/.msf4/archives will be used."],
            "-r"   => [ false,  "Create time stamped RC files of Meterpreter Sessions and console history for current project."],
            "-ph"  => [ false,  "Generate resource files for sessions and console. Generate time stamped session logs for current project."],
            "-l"   => [ false,  "List projects created by plugin."],
            "-h"   => [ false,  "Command Help"]
        )
        opts.parse(args) do |opt, idx, val|
          case opt
            when "-p"
              if ::File.directory?(val)
                arch_path =  val
              else
                print_error("Path provided for archive does not exists!")
                return
              end
            when "-d"
              delete = true
            when "-s"
              switch = true
            when "-a"
              archive = true
            when "-c"
              create = true
            when "-r"
              make_console_rc
              make_sessions_rc
            when "-h"
              print_line(opts.usage)
              return
            when "-l"
              list
              return
            when "-ph"
              history = true
            else
              project_name = val.gsub(" ","_").chomp
          end
        end
        if project_name and create
          project_create(project_name)
        elsif project_name and delete
          project_delete(project_name)
        elsif project_name and switch
          project_switch(project_name)
        elsif archive
          project_archive(arch_path)
        elsif history
          project_history
        else
          list
        end
      end

      def project_delete(project_name)
        # Check if project exists
        if project_list.include?(project_name)
          current_workspace = framework.db.workspace.name
          if current_workspace == project_name
            driver.init_ui(driver.input, Rex::Ui::Text::Output::Stdio.new)
          end
          workspace = framework.db.find_workspace(project_name)
          if workspace.default?
            workspace.destroy
            workspace = framework.db.add_workspace(project_name)
            print_line("Deleted and recreated the default workspace")
          else
            # switch to the default workspace if we're about to delete the current one
            framework.db.workspace = framework.db.default_workspace if framework.db.workspace.name == workspace.name
            # now destroy the named workspace
            workspace.destroy
            print_line("Deleted workspace: #{project_name}")
          end
          project_path = ::File.join(Msf::Config.log_directory,"projects",project_name)
          ::FileUtils.rm_rf(project_path)
          print_line("Project folder #{project_path} has been deleted")
        else
          print_error("Project was not found on list of projects!")
        end
        return true
      end

      # Switch to another project created by the plugin
      def project_switch(project_name)
        # Check if project exists
        if project_list.include?(project_name)
          print_line("Switching to #{project_name}")
          # Disable spooling for current
          driver.init_ui(driver.input, Rex::Ui::Text::Output::Stdio.new)

          # Switch workspace
          workspace = framework.db.find_workspace(project_name)
          framework.db.workspace = workspace
          print_line("Workspace: #{workspace.name}")

          # Spool
          spool_path = ::File.join(Msf::Config.log_directory,"projects",framework.db.workspace.name)
          spool_file = ::File.join(spool_path,"#{project_name}_spool.log")

          # Start spooling for new workspace
          driver.init_ui(driver.input, Rex::Ui::Text::Output::Tee.new(spool_file))
          print_line("Spooling to file #{spool_file}...")
          print_line("Successfully migrated to #{project_name}")

        else
          print_error("Project was not found on list of projects!")
        end
        return true
      end

      # List current projects created by the plugin
      def list
        current_workspace = framework.db.workspace.name
        print_line("List of projects:")
        project_list.each do |p|
          if current_workspace == p
            print_line("\t* #{p}")
          else
            print_line("\t#{p}")
          end
        end
        return true
      end

      # Archive project in to a zip file
      def project_archive(archive_path)
        # Set variables for options
        project_name = framework.db.workspace.name
        project_path = ::File.join(Msf::Config.log_directory,"projects",project_name)
        archive_name =  "#{project_name}_#{::Time.now.strftime("%Y%m%d.%M%S")}.zip"
        db_export_name = "#{project_name}_#{::Time.now.strftime("%Y%m%d.%M%S")}.xml"
        db_out = ::File.join(project_path,db_export_name)
        format = "xml"
        print_line("Exporting DB Workspace #{project_name}")
        exporter = Msf::DBManager::Export.new(framework.db.workspace)
        exporter.send("to_#{format}_file".intern,db_out) do |mtype, mstatus, mname|
          if mtype == :status
            if mstatus == "start"
              print_line("  >> Starting export of #{mname}")
            end
            if mstatus == "complete"
              print_line("  >> Finished export of #{mname}")
            end
          end
        end
        print_line("Finished export of workspace #{framework.db.workspace.name} to #{db_out} [ #{format} ]...")
        print_line("Disabling spooling for #{project_name}")
        driver.init_ui(driver.input, Rex::Ui::Text::Output::Stdio.new)
        print_line("Spooling disabled for archiving")
        archive_full_path = ::File.join(archive_path,archive_name)
        make_console_rc
        make_sessions_rc
        make_sessions_logs
        compress(project_path,archive_full_path)
        print_line("MD5 for archive is #{digestmd5(archive_full_path)}")
        # Spool
        spool_path = ::File.join(Msf::Config.log_directory,"projects",framework.db.workspace.name)
        spool_file = ::File.join(spool_path,"#{project_name}_spool.log")
        print_line("Spooling re-enabled")
        # Start spooling for new workspace
        driver.init_ui(driver.input, Rex::Ui::Text::Output::Tee.new(spool_file))
        print_line("Spooling to file #{spool_file}...")
        return true
      end

      # Export Command History for Sessions and Console
      #-------------------------------------------------------------------------------------------
      def project_history
        make_console_rc
        make_sessions_rc
        make_sessions_logs
        return true
      end

      # Create a new project Workspace and enable logging
      #-------------------------------------------------------------------------------------------
      def project_create(project_name)
        # Make sure that proper values where provided
        spool_path = ::File.join(Msf::Config.log_directory,"projects",project_name)
        ::FileUtils.mkdir_p(spool_path)
        spool_file = ::File.join(spool_path,"#{project_name}_spool.log")
        if framework.db and framework.db.active
          print_line("Creating DB Workspace named #{project_name}")
          workspace = framework.db.add_workspace(project_name)
          framework.db.workspace = workspace
          print_line("Added workspace: #{workspace.name}")
          driver.init_ui(driver.input, Rex::Ui::Text::Output::Tee.new(spool_file))
          print_line("Spooling to file #{spool_file}...")
        else
          print_error("A database most be configured and connected to create a project")
        end

        return true
      end

      # Method for creating a console resource file from all commands entered in the console
      #-------------------------------------------------------------------------------------------
      def make_console_rc
        # Set RC file path and file name
        rc_file = "#{framework.db.workspace.name}_#{::Time.now.strftime("%Y%m%d.%M%S")}.rc"
        consonle_rc_path = ::File.join(Msf::Config.log_directory,"projects",framework.db.workspace.name)
        rc_full_path = ::File.join(consonle_rc_path,rc_file)

        # Create folder
        ::FileUtils.mkdir_p(consonle_rc_path)
        con_rc = ""
        framework.db.workspace.events.each do |e|
          if not e.info.nil? and e.info.has_key?(:command) and not e.info.has_key?(:session_type)
            con_rc << "# command executed at #{e.created_at}\n"
            con_rc << "#{e.info[:command]}\n"
          end
        end

        # Write RC console file
        print_line("Writing Console RC file to #{rc_full_path}")
        file_write(rc_full_path, con_rc)
        print_line("RC file written")

        return rc_full_path
      end

      # Method for creating individual rc files per session using the session uuid
      #-------------------------------------------------------------------------------------------
      def make_sessions_rc
        sessions_uuids = []
        sessions_info = []
        info = ""
        rc_file = ""
        rc_file_name = ""
        rc_list =[]

        framework.db.workspace.events.each do |e|
          if not e.info.nil? and e.info.has_key?(:command) and e.info[:session_type] =~ /meter/
            if e.info[:command] != "load stdapi"
              if not sessions_uuids.include?(e.info[:session_uuid])
                sessions_uuids << e.info[:session_uuid]
                sessions_info << {:uuid => e.info[:session_uuid],
                                  :type => e.info[:session_type],
                                  :id => e.info[:session_id],
                                  :info => e.info[:session_info]}
              end
            end
          end
        end

        sessions_uuids.each do |su|
          sessions_info.each do |i|
            if su == i[:uuid]
              print_line("Creating RC file for Session #{i[:id]}")
              rc_file_name = "#{framework.db.workspace.name}_session_#{i[:id]}_#{::Time.now.strftime("%Y%m%d.%M%S")}.rc"
              i.each do |k,v|
                info << "#{k.to_s}: #{v.to_s} "
              end
              break
            end
          end
          rc_file << "# Info: #{info}\n"
          info = ""
          framework.db.workspace.events.each do |e|
            if not e.info.nil? and e.info.has_key?(:command) and e.info.has_key?(:session_uuid)
              if e.info[:session_uuid] == su
                rc_file << "# command executed at #{e.created_at}\n"
                rc_file << "#{e.info[:command]}\n"
              end
            end
          end
          # Set RC file path and file name
          consonle_rc_path = ::File.join(Msf::Config.log_directory,"projects",framework.db.workspace.name)
          rc_full_path = ::File.join(consonle_rc_path,rc_file_name)
          print_line("Saving RC file to #{rc_full_path}")
          file_write(rc_full_path, rc_file)
          rc_file = ""
          print_line("RC file written")
          rc_list << rc_full_path
        end

        return rc_list
      end

      # Method for exporting session history with output
      #-------------------------------------------------------------------------------------------
      def make_sessions_logs
        sessions_uuids = []
        sessions_info = []
        info = ""
        hist_file = ""
        hist_file_name = ""
        log_list = []

        # Create list of sessions with base info
        framework.db.workspace.events.each do |e|
          if not e.info.nil? and e.info[:session_type] =~ /shell/ or e.info[:session_type] =~ /meter/
            if e.info[:command] != "load stdapi"
              if not sessions_uuids.include?(e.info[:session_uuid])
                sessions_uuids << e.info[:session_uuid]
                sessions_info << {:uuid => e.info[:session_uuid],
                                  :type => e.info[:session_type],
                                  :id => e.info[:session_id],
                                  :info => e.info[:session_info]}
              end
            end
          end
        end

        sessions_uuids.each do |su|
          sessions_info.each do |i|
            if su == i[:uuid]
              print_line("Exporting Session #{i[:id]} history")
              hist_file_name = "#{framework.db.workspace.name}_session_#{i[:id]}_#{::Time.now.strftime("%Y%m%d.%M%S")}.log"
              i.each do |k,v|
                info << "#{k.to_s}: #{v.to_s} "
              end
              break
            end
          end
          hist_file << "# Info: #{info}\n"
          info = ""
          framework.db.workspace.events.each do |e|
            if not e.info.nil? and e.info.has_key?(:command) or e.info.has_key?(:output)
              if e.info[:session_uuid] == su
                if e.info.has_key?(:command)
                  hist_file << "#{e.updated_at}\n"
                  hist_file << "#{e.info[:command]}\n"
                elsif e.info.has_key?(:output)
                  hist_file << "#{e.updated_at}\n"
                  hist_file << "#{e.info[:output]}\n"
                end
              end
            end
          end

          # Set RC file path and file name
          session_hist_path = ::File.join(Msf::Config.log_directory,"projects",framework.db.workspace.name)
          session_hist_fullpath = ::File.join(session_hist_path,hist_file_name)

          # Create folder
          ::FileUtils.mkdir_p(session_hist_path)

          print_line("Saving log file to #{session_hist_fullpath}")
          file_write(session_hist_fullpath, hist_file)
          hist_file = ""
          print_line("Log file written")
          log_list << session_hist_fullpath
        end

        return log_list
      end

      # Compress a given folder given it's path
      #-------------------------------------------------------------------------------------------
      def compress(path,archive)
        require 'zip/zip'
        require 'zip/zipfilesystem'

        path.sub!(%r[/$],'')
        ::Zip::ZipFile.open(archive, 'w') do |zipfile|
          Dir["#{path}/**/**"].reject{|f|f==archive}.each do |file|
            print_line("Adding #{file} to archive")
            zipfile.add(file.sub(path+'/',''),file)
          end
        end
        print_line("All files saved to #{archive}")
      end

      # Method to write string to file
      def file_write(file2wrt, data2wrt)
        if not ::File.exists?(file2wrt)
          ::FileUtils.touch(file2wrt)
        end

        output = ::File.open(file2wrt, "a")
        data2wrt.each_line do |d|
          output.puts(d)
        end
        output.close
      end

      # Method to create MD5 of given file
      def digestmd5(file2md5)
        if not ::File.exists?(file2md5)
          raise "File #{file2md5} does not exists!"
        else
          require 'digest/md5'
          chksum = nil
          chksum = Digest::MD5.hexdigest(::File.open(file2md5, "rb") { |f| f.read})
          return chksum
        end
      end

      # Method that returns a hash of projects
      def project_list
        project_folders = Dir::entries(::File.join(Msf::Config.log_directory,"projects"))
        projects = []
        framework.db.workspaces.each do |s|
          if project_folders.include?(s.name)
            projects << s.name
          end
        end
        return projects
      end

    end

    def initialize(framework, opts)
      super
      if framework.db and framework.db.active
        add_console_dispatcher(PostautoCommandDispatcher)
        add_console_dispatcher(ProjectCommandDispatcher)

        archive_path =  ::File.join(Msf::Config.log_directory,"archives")
        project_paths = ::File.join(Msf::Config.log_directory,"projects")

        # Create project folder if first run
        if not ::File.directory?(project_paths)
          ::FileUtils.mkdir_p(project_paths)
        end

        # Create archive folder if first run
        if not ::File.directory?(archive_path)
          ::FileUtils.mkdir_p(archive_path)
        end
        banner = %{
       ___         _          _     ___ _           _
      | _ \\___ _ _| |_ ___ __| |_  | _ \\ |_  _ __ _(_)_ _
      |  _/ -_) ' \\  _/ -_|_-<  _| |  _/ | || / _` | | ' \\
      |_| \\___|_||_\\__\\___/__/\\__| |_| |_|\\_,_\\__, |_|_||_|
                                              |___/
      }
        print_line banner
        print_line "MultiPost plugin loaded."
      else
        print_error("This plugin requires the framework to be connected to a Database!")
      end
    end

    def cleanup
      remove_console_dispatcher('Postauto')
    end

    def name
      "multipost"
    end

    def desc
      "Plugin for Post-Exploitation automation."
    end
    protected
  end
end